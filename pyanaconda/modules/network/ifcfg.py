#
# Handling of ifcfg files
#
# Copyright (C) 2019 Red Hat, Inc.
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# the GNU General Public License v.2, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY expressed or implied, including the implied warranties of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.  You should have received a copy of the
# GNU General Public License along with this program; if not, write to the
# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.  Any Red Hat trademarks that are incorporated in the
# source code or documentation are not subject to the GNU General Public
# License and may only be used or replicated with the express permission of
# Red Hat, Inc.
#

import os

# TODO move to anaconda.core
from pyanaconda.simpleconfig import SimpleConfigFile
from pyanaconda.core import util
from pyanaconda.modules.network.constants import NM_CONNECTION_UUID_LENGTH
from pyanaconda.modules.network.kickstart import default_ks_vlan_interface_name
from pyanaconda.modules.network.utils import is_s390, prefix2netmask
from pyanaconda.modules.network.nm_client import get_iface_from_hwaddr, get_iface_from_connection, \
    get_team_port_config_from_connection, get_team_config_form_connection


from pyanaconda.anaconda_loggers import get_module_logger
log = get_module_logger(__name__)


IFCFG_DIR = "/etc/sysconfig/network-scripts"


class IfcfgFile(SimpleConfigFile):
    def __init__(self, filename):
        SimpleConfigFile.__init__(self, always_quote=True, filename=filename)
        self._dirty = False
        self._path = filename
        self._uuid = None
        self._loaded = False

    @property
    def uuid(self):
        if not self._loaded:
            self.read()
        return self.get('UUID')

    @property
    def path(self):
        return self._path

    def read(self, filename=None):
        self.reset()
        SimpleConfigFile.read(self)
        self._loaded = True
        self._dirty = False

    def write(self, filename=None, use_tmp=False):
        if self._dirty or filename:
            # ifcfg-rh is using inotify IN_CLOSE_WRITE event so we don't use
            # temporary file for new configuration
            SimpleConfigFile.write(self, filename, use_tmp=use_tmp)
            self._dirty = False

    def set(self, *args):
        for (key, data) in args:
            if self.get(key) != data:
                break
        else:
            return
        SimpleConfigFile.set(self, *args)
        self._dirty = True

    def unset(self, *args):
        for key in args:
            if self.get(key):
                self._dirty = True
                break
        else:
            return
        SimpleConfigFile.unset(self, *args)

    @property
    def is_from_kickstart(self):
        with open(self.path, 'r') as f:
            return "Generated by parse-kickstart" in f.read()


def _ifcfg_files(directory):
    rv = []
    for name in os.listdir(directory):
        if name.startswith("ifcfg-"):
            if name == "ifcfg-lo":
                continue
            rv.append(os.path.join(directory, name))
    return rv


def get_ifcfg_file(values, root_path=""):
    for file_path in _ifcfg_files(os.path.normpath(root_path + IFCFG_DIR)):
        ifcfg = IfcfgFile(file_path)
        ifcfg.read()
        for key, value in values:
            if callable(value):
                if not value(ifcfg.get(key)):
                    break
            else:
                if ifcfg.get(key) != value:
                    break
        else:
            return ifcfg
    return None


def find_ifcfg_uuid_of_device(nm_client, device_name, hwaddr=None, root_path=""):
    uuid = None
    ifcfg = get_ifcfg_file_of_device(nm_client, device_name, hwaddr, root_path)
    if ifcfg:
        uuid = ifcfg.uuid
    return uuid


def get_ifcfg_file_of_device(nm_client, device_name, device_hwaddr=None, root_path=""):
    # hwaddr is supplementary (--bindto=mac)
    ifcfgs = []
    for file_path in _ifcfg_files(os.path.normpath(root_path + IFCFG_DIR)):
        ifcfg = IfcfgFile(file_path)
        ifcfg.read()
        device_type = ifcfg.get("TYPE") or ifcfg.get("DEVICETYPE")
        if device_type == "Wireless":
            # TODO check ESSID against active ssid of the device
            pass
        elif device_type in ("Bond", "Team", "Bridge", "Infiniband"):
            if ifcfg.get("DEVICE") == device_name:
                ifcfgs.append(ifcfg)
        elif device_type == "Vlan":
            interface_name = ifcfg.get("DEVICE")
            if interface_name:
                if interface_name == device_name:
                    ifcfgs.append(ifcfg)
            else:
                physdev = ifcfg.get("PHYSDEV")
                if len(physdev) == NM_CONNECTION_UUID_LENGTH:
                    physdev = get_iface_from_connection(nm_client, physdev)
                vlanid = ifcfg.get("VLAN_ID")
                generated_dev_name = default_ks_vlan_interface_name(physdev, vlanid)
                if device_name == generated_dev_name:
                    ifcfgs.append(ifcfg)

        elif device_type == "Ethernet":
            # Ignore slaves
            if ifcfg.get("MASTER") or ifcfg.get("TEAM_MASTER") or ifcfg.get("BRIDGE"):
                continue
            device = ifcfg.get("DEVICE")
            hwaddr = ifcfg.get("HWADDR")
            if device:
                if device == device_name:
                    ifcfgs.append(ifcfg)
            elif hwaddr:
                if device_hwaddr:
                    if device_hwaddr.upper() == hwaddr.upper():
                        ifcfgs.append(ifcfg)
                else:
                    iface = get_iface_from_hwaddr(nm_client, hwaddr)
                    if iface == device_name:
                        ifcfgs.append(ifcfg)
            elif is_s390():
                # s390 setting generated in dracut with net.ifnames=0
                # has neither DEVICE nor HWADDR (#1249750)
                if device.get("NAME") == device_name:
                    ifcfgs.append(ifcfg)

    if len(ifcfgs) > 1:
        log.debug("Unexpected number of ifcfg files found for %s: %s", device_name,
                  [ifcfg.path for ifcfg in ifcfgs])
    if ifcfgs:
        return ifcfgs[0]
    else:
        log.debug("Ifcfg file for %s not found", device_name)


def get_slaves_from_ifcfgs(nm_client, master_option, master_specs, root_path=""):
    """List of slaves of master specified by master_specs in master_option.

       master_option is ifcfg option containing spec of master
       master_specs is a list containing device name of master (dracut)
       and/or master's connection uuid
    """
    slaves = []

    for file_path in _ifcfg_files(os.path.normpath(root_path + IFCFG_DIR)):
        ifcfg = IfcfgFile(file_path)
        ifcfg.read()
        master = ifcfg.get(master_option)
        if master in master_specs:
            iface = ifcfg.get("DEVICE")
            if not iface:
                hwaddr = ifcfg.get("HWADDR")
                iface = nm_client.get_iface_from_hwaddr(nm_client, hwaddr)
            if iface:
                slaves.append((iface, ifcfg.get("UUID")))
    return slaves


def get_kickstart_network_data(ifcfg, nm_client, network_data_class):
    """Get kickstart data from ifcfg object."""
    ifcfg.read()
    kwargs = {}

    # no network command for non-virtual device slaves
    if ifcfg.get("TYPE") not in ("Bond", "Team"):
        if ifcfg.get("MASTER") or ifcfg.get("TEAM_MASTER") or ifcfg.get("BRIDGE"):
            return None

    # ipv4 and ipv6
    if ifcfg.get("ONBOOT") and ifcfg.get("ONBOOT") == "no":
        kwargs["onboot"] = False
    if ifcfg.get('MTU') and ifcfg.get('MTU') != "0":
        kwargs["mtu"] = ifcfg.get('MTU')
    # ipv4
    if not ifcfg.get('BOOTPROTO'):
        kwargs["noipv4"] = True
    else:
        if util.lowerASCII(ifcfg.get('BOOTPROTO')) == 'dhcp':
            kwargs["bootProto"] = "dhcp"
            if ifcfg.get('DHCPCLASS'):
                kwargs["dhcpclass"] = ifcfg.get('DHCPCLASS')
        elif ifcfg.get('IPADDR'):
            kwargs["bootProto"] = "static"
            kwargs["ip"] = ifcfg.get('IPADDR')
            netmask = ifcfg.get('NETMASK')
            prefix = ifcfg.get('PREFIX')
            if not netmask and prefix:
                netmask = prefix2netmask(int(prefix))
            if netmask:
                kwargs["netmask"] = netmask
            # note that --gateway is common for ipv4 and ipv6
            if ifcfg.get('GATEWAY'):
                kwargs["gateway"] = ifcfg.get('GATEWAY')
        elif ifcfg.get('IPADDR0'):
            kwargs["bootProto"] = "static"
            kwargs["ip"] = ifcfg.get('IPADDR0')
            prefix = ifcfg.get('PREFIX0')
            if prefix:
                netmask = prefix2netmask(int(prefix))
                kwargs["netmask"] = netmask
            # note that --gateway is common for ipv4 and ipv6
            if ifcfg.get('GATEWAY0'):
                kwargs["gateway"] = ifcfg.get('GATEWAY0')

    # ipv6
    if not ifcfg.get('IPV6INIT') or ifcfg.get('IPV6INIT') == "no":
        kwargs["noipv6"] = True
    else:
        if ifcfg.get('IPV6_AUTOCONF') in ("yes", ""):
            kwargs["ipv6"] = "auto"
        else:
            if ifcfg.get('IPV6ADDR'):
                kwargs["ipv6"] = ifcfg.get('IPV6ADDR')
                if ifcfg.get('IPV6_DEFAULTGW') \
                        and ifcfg.get('IPV6_DEFAULTGW') != "::":
                    kwargs["ipv6gateway"] = ifcfg.get('IPV6_DEFAULTGW')
            if ifcfg.get('DHCPV6C') == "yes":
                kwargs["ipv6"] = "dhcp"

    # ipv4 and ipv6
    dnsline = ''
    for key in ifcfg.info.keys():
        if util.upperASCII(key).startswith('DNS'):
            if dnsline == '':
                dnsline = ifcfg.get(key)
            else:
                dnsline += "," + ifcfg.get(key)
    if dnsline:
        kwargs["nameserver"] = dnsline

    if ifcfg.get("ETHTOOL_OPTS"):
        kwargs["ethtool"] = ifcfg.get("ETHTOOL_OPTS")

    if ifcfg.get("ESSID"):
        kwargs["essid"] = ifcfg.get("ESSID")

    # hostname
    if ifcfg.get("DHCP_HOSTNAME"):
        kwargs["hostname"] = ifcfg.get("DHCP_HOSTNAME")

    iface = ifcfg.get("DEVICE")
    if not iface:
        hwaddr = ifcfg.get("HWADDR")
        if hwaddr:
            iface = get_iface_from_hwaddr(nm_client, hwaddr)
    if iface:
        kwargs["device"] = iface

    # bonding
    # FIXME: dracut has only BOND_OPTS
    if ifcfg.get("BONDING_MASTER") == "yes" or ifcfg.get("TYPE") == "Bond":
        slaves = get_slaves_from_ifcfgs(nm_client, "MASTER", [ifcfg.get("DEVICE"), ifcfg.get("UUID")])
        if slaves:
            kwargs["bondslaves"] = ",".join(iface for iface, uuid in slaves)
        bondopts = ifcfg.get("BONDING_OPTS")
        if bondopts:
            sep = ","
            if sep in bondopts:
                sep = ";"
            kwargs["bondopts"] = sep.join(bondopts.split())

    # vlan
    if ifcfg.get("VLAN") == "yes" or ifcfg.get("TYPE") == "Vlan":
        physdev = ifcfg.get("PHYSDEV")
        if len(physdev) == NM_CONNECTION_UUID_LENGTH:
            physdev = get_iface_from_connection(nm_client, physdev)
        kwargs["device"] = physdev
        kwargs["vlanid"] = ifcfg.get("VLAN_ID")
        interface_name = ifcfg.get("DEVICE")
        if interface_name and interface_name != default_ks_vlan_interface_name(kwargs["device"], kwargs["vlanid"]):
            kwargs["interfacename"] = interface_name

    # bridging
    if ifcfg.get("TYPE") == "Bridge":
        slaves = get_slaves_from_ifcfgs(nm_client, "BRIDGE", [ifcfg.get("DEVICE"), ifcfg.get("UUID")])
        if slaves:
            kwargs["bridgeslaves"] = ",".join(iface for iface, uuid in slaves)

        bridgeopts = ifcfg.get("BRIDGING_OPTS").replace('_', '-').split()
        if ifcfg.get("STP"):
            bridgeopts.append("%s=%s" % ("stp", ifcfg.get("STP")))
        if ifcfg.get("DELAY"):
            bridgeopts.append("%s=%s" % ("forward-delay", ifcfg.get("DELAY")))
        if bridgeopts:
            kwargs["bridgeopts"] = ",".join(bridgeopts)

    nd = network_data_class(**kwargs)

    # teaming
    if ifcfg.get("TYPE") == "Team" or ifcfg.get("DEVICETYPE") == "Team":
        slaves = get_slaves_from_ifcfgs(nm_client, "TEAM_MASTER", [ifcfg.get("DEVICE"), ifcfg.get("UUID")])
        for iface, uuid in slaves:
            team_port_cfg = get_team_port_config_from_connection(nm_client, uuid)
            nd.teamslaves.append((iface, team_port_cfg))
        teamconfig = get_team_config_form_connection(nm_client, ifcfg.get("UUID"))
        if teamconfig:
            nd.teamconfig = teamconfig
    return nd


def update_onboot_value(connection_uuid, onboot, root_path=""):
    """Update onboot value in ifcfg files.

    :param connection_uuid: uuid of the connection to be updated
    :type devname: str
    :param onboot: value of ONBOOT setting
    :type onboot: bool
    :param root_path: optional root path for ifcfg files to be updated
    :type root_path: str
    :returns: True if the value was updated, False otherwise
    :rtype: bool
    """

    ifcfg = get_ifcfg_file([("UUID", connection_uuid)])
    if not ifcfg:
        log.debug("can't find ifcfg file of %s", connection_uuid)
        return False

    ifcfg.read()
    old_value = ifcfg.get('ONBOOT')
    new_value = "yes" if onboot else "no"
    log.debug("updating ONBOOT value of %s from %s to %s", connection_uuid, old_value, new_value)
    ifcfg.set(('ONBOOT', new_value))
    ifcfg.write()

    return True


def update_slaves_onboot_value(nm_client, master_devname, onboot, root_path="", uuid=None):
    """Update onboot value in slave ifcfg files of given master.

    Master can be identified by device name or uuid. If uuid is not provided
    as argument it will be looked up in master's ifcfg file.

    :param master_devname: name of master device
    :type devname: str
    :param onboot: value of ONBOOT setting
    :type onboot: bool
    :param root_path: optional root path for ifcfg files to be updated
    :type root_path: str
    :param uuid: uuid of master connection (optional)
    :type uuid: str
    :returns: True if the value was updated, False otherwise
    :rtype: bool
    """
    new_value = "yes" if onboot else "no"
    updated_devices = []
    # Master can be identified by devname or uuid, try to find master uuid
    if not uuid:
        uuid = find_ifcfg_uuid_of_device(nm_client, master_devname, root_path=root_path)
    for ifcfg_path in _ifcfg_files(os.path.normpath(root_path + IFCFG_DIR)):
        ifcfg = IfcfgFile(ifcfg_path)
        ifcfg.read()
        master = ifcfg.get("MASTER") or ifcfg.get("TEAM_MASTER") or ifcfg.get("BRIDGE")
        if master in (master_devname, uuid):
            old_value = ifcfg.get('ONBOOT')
            slave = ifcfg.get("NAME")
            log.debug("updating ONBOOT value of slave %s from %s to %s", slave, old_value, new_value)
            ifcfg.set(('ONBOOT', new_value))
            ifcfg.write()
            updated_devices.append(slave)

    return updated_devices


def get_dracut_arguments_from_ifcfg(nm_client, iface, target_ip, hostname):
    """Get dracut arguments for the iface and iSCSI target.

    The dracut arguments would activate the iface in initramfs so that the
    iSCSI target can be attached (for example to mount root filesystem).

    :param iface: network interface used to connect to the target
    :type iface: str
    :param target_ip: IP of the iSCSI target
    :type target_ip: str
    :param hostname: static hostname to be configured
    :type hostname: str
    """
    netargs = set()
    ifcfg = get_ifcfg_file_of_device(nm_client, iface)
    if not ifcfg:
        log.error("get dracut arguments from ifcfg for %s: no ifcfg file found", iface)
        return list(netargs)

    if ifcfg.get('BOOTPROTO') == 'ibft':
        netargs.add("rd.iscsi.ibft")
    elif target_ip:
        if hostname is None:
            hostname = ""
        # if using ipv6
        if ':' in target_ip:
            if ifcfg.get('DHCPV6C') == "yes":
                # XXX combination with autoconf not yet clear,
                # support for dhcpv6 is not yet implemented in NM/ifcfg-rh
                netargs.add("ip=%s:dhcp6" % iface)
            elif ifcfg.get('IPV6_AUTOCONF') == "yes":
                netargs.add("ip=%s:auto6" % iface)
            elif ifcfg.get('IPV6ADDR'):
                ipaddr = "[%s]" % ifcfg.get('IPV6ADDR')
                if ifcfg.get('IPV6_DEFAULTGW'):
                    gateway = "[%s]" % ifcfg.get('IPV6_DEFAULTGW')
                else:
                    gateway = ""
                netargs.add("ip=%s::%s::%s:%s:none" % (ipaddr, gateway,
                            hostname, iface))
        else:
            if util.lowerASCII(ifcfg.get('bootproto')) == 'dhcp':
                netargs.add("ip=%s:dhcp" % iface)
            else:
                cfgidx = ''
                if ifcfg.get('IPADDR0'):
                    cfgidx = '0'
                if ifcfg.get('GATEWAY%s' % cfgidx):
                    gateway = ifcfg.get('GATEWAY%s' % cfgidx)
                else:
                    gateway = ""
                netmask = ifcfg.get('NETMASK%s' % cfgidx)
                prefix = ifcfg.get('PREFIX%s' % cfgidx)
                if not netmask and prefix:
                    netmask = prefix2netmask(int(prefix))
                ipaddr = ifcfg.get('IPADDR%s' % cfgidx)
                netargs.add("ip=%s::%s:%s:%s:%s:none" %
                            (ipaddr, gateway, netmask, hostname, iface))

        hwaddr = ifcfg.get("HWADDR")
        if hwaddr:
            netargs.add("ifname=%s:%s" % (iface, hwaddr.lower()))

        if ifcfg.get("TYPE") == "Team" or ifcfg.get("DEVICETYPE") == "Team":
            slaves = get_slaves_from_ifcfgs(nm_client, "TEAM_MASTER", [iface, ifcfg.get("UUID")])
            netargs.add("team=%s:%s" % (iface,
                                        ",".join(s_iface for s_iface, _uuid in slaves)))

        if ifcfg.get("TYPE") == "Vlan":
            physdev_spec = ifcfg.get("PHYSDEV")
            physdev = None
            # physical device can be specified by connection uuid (eg from nm-c-e)
            if len(physdev_spec) == NM_CONNECTION_UUID_LENGTH:
                ifcfg = get_ifcfg_file([("UUID", physdev_spec)])
                if ifcfg:
                    # On s390 with net.ifnames=0 there is no DEVICE
                    physdev = ifcfg.get("DEVICE") or ifcfg.get("NAME")
            else:
                ifcfg = get_ifcfg_file_of_device(nm_client, physdev_spec)
                if ifcfg:
                    physdev = physdev_spec
            if physdev:
                netargs.add("vlan=%s:%s" % (iface, physdev))
            else:
                log.error("can't find ifcfg of parent of vlan device %s specified by %s",
                          iface, physdev_spec)
                return list(netargs)

    # For vlan ifcfg now refers to the physical device file
    nettype = ifcfg.get("NETTYPE")
    subchannels = ifcfg.get("SUBCHANNELS")
    if is_s390() and nettype and subchannels:
        znet = "rd.znet=%s,%s" % (nettype, subchannels)
        options = ifcfg.get("OPTIONS").strip("'\"")
        if options:
            options = filter(lambda x: x != '', options.split(' '))
            znet += ",%s" % (','.join(options))
        netargs.add(znet)

    return list(netargs)
